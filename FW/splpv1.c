/* Generated by re2c 1.3 on Thu Oct 14 23:29:49 2021 */
/*
  Рагусский Ричард Викторович
  14 группа
*/
/*
  In case of encoding problems:
  Richard Ragusski
  Group 14
*/

#include "splpv1.h"

inline unsigned char lexConnect(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'C') goto yy4;
        ++YYCURSOR;
        yy3:
        { return 0;}
        yy4:
        yych = *(++YYCURSOR);
        if (yych != 'O') goto yy3;
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy7;
        yy7:
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy3;
        yych = *++YYCURSOR;
        if (yych != 'E') goto yy3;
        yych = *++YYCURSOR;
        if (yych != 'C') goto yy3;
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy3;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy3;
        ++YYCURSOR;
        { return 1;}
    }

}
inline unsigned char lexCmd(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'D') goto yy18;
        if (yych == 'G') goto yy19;
        ++YYCURSOR;
        yy17:
        { return 0;}
        yy18:
        yych = *(++YYCURSOR);
        if (yych == 'I') goto yy20;
        goto yy17;
        yy19:
        yych = *(++YYCURSOR);
        if (yych == 'E') goto yy22;
        goto yy17;
        yy20:
        yych = *++YYCURSOR;
        if (yych == 'S') goto yy23;
        yy22:
        yych = *++YYCURSOR;
        if (yych == 'T') goto yy24;
        goto yy17;
        yy23:
        yych = *++YYCURSOR;
        if (yych == 'C') goto yy25;
        goto yy17;
        yy24:
        yych = *++YYCURSOR;
        if (yych == '_') goto yy26;
        goto yy17;
        yy25:
        yych = *++YYCURSOR;
        if (yych == 'O') goto yy27;
        goto yy17;
        yy26:
        yych = *++YYCURSOR;
        switch (yych) {
            case 'B':	goto yy28;
            case 'C':	goto yy29;
            case 'D':	goto yy30;
            case 'F':	goto yy31;
            case 'V':	goto yy32;
            default:	goto yy17;
        }
        yy27:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy33;
        goto yy17;
        yy28:
        yych = *++YYCURSOR;
        if (yych == '6') goto yy34;
        goto yy17;
        yy29:
        yych = *++YYCURSOR;
        if (yych == 'O') goto yy35;
        goto yy17;
        yy30:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy36;
        goto yy17;
        yy31:
        yych = *++YYCURSOR;
        if (yych == 'I') goto yy37;
        goto yy17;
        yy32:
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy38;
        goto yy17;
        yy33:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy39;
        goto yy17;
        yy34:
        yych = *++YYCURSOR;
        if (yych == '4') goto yy40;
        goto yy17;
        yy35:
        yych = *++YYCURSOR;
        if (yych == 'M') goto yy41;
        goto yy17;
        yy36:
        yych = *++YYCURSOR;
        if (yych == 'T') goto yy42;
        goto yy17;
        yy37:
        yych = *++YYCURSOR;
        if (yych == 'L') goto yy43;
        goto yy17;
        yy38:
        yych = *++YYCURSOR;
        if (yych == 'R') goto yy44;
        goto yy17;
        yy39:
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy45;
        goto yy17;
        yy40:
        yych = *++YYCURSOR;
        if (yych <= 0x00) goto yy46;
        goto yy17;
        yy41:
        yych = *++YYCURSOR;
        if (yych == 'M') goto yy48;
        goto yy17;
        yy42:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy49;
        goto yy17;
        yy43:
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy49;
        goto yy17;
        yy44:
        yych = *++YYCURSOR;
        if (yych <= 0x00) goto yy50;
        goto yy17;
        yy45:
        yych = *++YYCURSOR;
        if (yych == 'C') goto yy52;
        goto yy17;
        yy46:
        ++YYCURSOR;
        { return 6;}
        yy48:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy53;
        goto yy17;
        yy49:
        yych = *++YYCURSOR;
        if (yych <= 0x00) goto yy54;
        goto yy17;
        yy50:
        ++YYCURSOR;
        { return 4;}
        yy52:
        yych = *++YYCURSOR;
        if (yych == 'T') goto yy56;
        goto yy17;
        yy53:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy57;
        goto yy17;
        yy54:
        ++YYCURSOR;
        { return 5;}
        yy56:
        yych = *++YYCURSOR;
        if (yych <= 0x00) goto yy58;
        goto yy17;
        yy57:
        yych = *++YYCURSOR;
        if (yych == 'D') goto yy49;
        goto yy17;
        yy58:
        ++YYCURSOR;
        { return 7;}
    }

}
inline unsigned char lexVer(const char *YYCURSOR){

    {
        unsigned char yych;
        static const unsigned char yybm[] = {
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                128, 128, 128, 128, 128, 128, 128, 128,
                128, 128,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
                0,   0,   0,   0,   0,   0,   0,   0,
        };
        yych = *YYCURSOR;
        if (yych == 'V') goto yy64;
        ++YYCURSOR;
        yy63:
        { return 0;}
        yy64:
        yych = *(++YYCURSOR);
        if (yych != 'E') goto yy63;
        yych = *++YYCURSOR;
        if (yych == 'R') goto yy67;
        yy67:
        yych = *++YYCURSOR;
        if (yych != 'S') goto yy63;
        yych = *++YYCURSOR;
        if (yych != 'I') goto yy63;
        yych = *++YYCURSOR;
        if (yych != 'O') goto yy63;
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy63;
        yych = *++YYCURSOR;
        if (yych != ' ') goto yy63;
        yych = *++YYCURSOR;
        if (yych <= 0x00) goto yy63;
        goto yy74;
        yy73:
        yych = *++YYCURSOR;
        yy74:
        if (yybm[0+yych] & 128) {
            goto yy73;
        }
        if (yych >= 0x01) goto yy63;
        ++YYCURSOR;
        { return 3;}
    }

}
inline unsigned char lexConnectOk(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'C') goto yy81;
        ++YYCURSOR;
        yy80:
        { return 0;}
        yy81:
        yych = *(++YYCURSOR);
        if (yych != 'O') goto yy80;
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy84;
        yy84:
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy80;
        yych = *++YYCURSOR;
        if (yych != 'E') goto yy80;
        yych = *++YYCURSOR;
        if (yych != 'C') goto yy80;
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy80;
        yych = *++YYCURSOR;
        if (yych != '_') goto yy80;
        yych = *++YYCURSOR;
        if (yych != 'O') goto yy80;
        yych = *++YYCURSOR;
        if (yych != 'K') goto yy80;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy80;
        ++YYCURSOR;
        { return 3;}
    }

}
inline unsigned char lexDisconnectOk(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'D') goto yy98;
        ++YYCURSOR;
        yy97:
        { return 0;}
        yy98:
        yych = *(++YYCURSOR);
        if (yych != 'I') goto yy97;
        yych = *++YYCURSOR;
        if (yych == 'S') goto yy101;
        yy101:
        yych = *++YYCURSOR;
        if (yych != 'C') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'O') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'E') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'C') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy97;
        yych = *++YYCURSOR;
        if (yych != '_') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'O') goto yy97;
        yych = *++YYCURSOR;
        if (yych != 'K') goto yy97;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy97;
        ++YYCURSOR;
        { return 1;}
    }

}
inline unsigned char lexB64New(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'B') goto yy118;
        ++YYCURSOR;
        yy117:
        { return 0;}
        yy118:
        yych = *(++YYCURSOR);
        if (yych != '6') goto yy117;
        yych = *++YYCURSOR;
        if (yych == '4') goto yy121;
        yy121:
        yych = *++YYCURSOR;
        if (yych != ':') goto yy117;
        yych = *++YYCURSOR;
        if (yych != ' ') goto yy117;
        ++YYCURSOR;
        { return 3;}
    }

}
inline unsigned char lexDFCStart(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == 'G') goto yy129;
        ++YYCURSOR;
        yy128:
        { return 0;}
        yy129:
        yych = *(++YYCURSOR);
        if (yych != 'E') goto yy128;
        yych = *++YYCURSOR;
        if (yych == 'T') goto yy132;
        yy132:
        yych = *++YYCURSOR;
        if (yych != '_') goto yy128;
        yych = *++YYCURSOR;
        if (yych <= 'D') {
            if (yych <= 'B') goto yy128;
            if (yych >= 'D') goto yy135;
        } else {
            if (yych == 'F') goto yy136;
            goto yy128;
        }
        yych = *++YYCURSOR;
        if (yych == 'O') goto yy137;
        goto yy128;
        yy135:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy138;
        goto yy128;
        yy136:
        yych = *++YYCURSOR;
        if (yych == 'I') goto yy139;
        goto yy128;
        yy137:
        yych = *++YYCURSOR;
        if (yych == 'M') goto yy140;
        goto yy128;
        yy138:
        yych = *++YYCURSOR;
        if (yych == 'T') goto yy141;
        goto yy128;
        yy139:
        yych = *++YYCURSOR;
        if (yych == 'L') goto yy142;
        goto yy128;
        yy140:
        yych = *++YYCURSOR;
        if (yych == 'M') goto yy143;
        goto yy128;
        yy141:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy144;
        goto yy128;
        yy142:
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy145;
        goto yy128;
        yy143:
        yych = *++YYCURSOR;
        if (yych == 'A') goto yy146;
        goto yy128;
        yy144:
        yych = *++YYCURSOR;
        if (yych == ' ') goto yy147;
        goto yy128;
        yy145:
        yych = *++YYCURSOR;
        if (yych == ' ') goto yy149;
        goto yy128;
        yy146:
        yych = *++YYCURSOR;
        if (yych == 'N') goto yy151;
        goto yy128;
        yy147:
        ++YYCURSOR;
        {return 11;}
        yy149:
        ++YYCURSOR;
        {return 12;}
        yy151:
        yych = *++YYCURSOR;
        if (yych != 'D') goto yy128;
        yych = *++YYCURSOR;
        if (yych != ' ') goto yy128;
        ++YYCURSOR;
        {return 13;}
    }

}
inline unsigned char lexDFCData(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == ' ') goto yy159;
        ++YYCURSOR;
        yy158:
        { return 0;}
        yy159:
        yych = *(++YYCURSOR);
        if (yych != 'G') goto yy158;
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy162;
        yy162:
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy158;
        yych = *++YYCURSOR;
        if (yych != '_') goto yy158;
        yych = *++YYCURSOR;
        if (yych != 'D') goto yy158;
        yych = *++YYCURSOR;
        if (yych != 'A') goto yy158;
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy158;
        yych = *++YYCURSOR;
        if (yych != 'A') goto yy158;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy158;
        ++YYCURSOR;
        {return 1;}
    }

}
inline unsigned char lexDFCFile(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == ' ') goto yy175;
        ++YYCURSOR;
        yy174:
        { return 0;}
        yy175:
        yych = *(++YYCURSOR);
        if (yych != 'G') goto yy174;
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy178;
        yy178:
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy174;
        yych = *++YYCURSOR;
        if (yych != '_') goto yy174;
        yych = *++YYCURSOR;
        if (yych != 'F') goto yy174;
        yych = *++YYCURSOR;
        if (yych != 'I') goto yy174;
        yych = *++YYCURSOR;
        if (yych != 'L') goto yy174;
        yych = *++YYCURSOR;
        if (yych != 'E') goto yy174;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy174;
        ++YYCURSOR;
        {return 1;}
    }

}
inline unsigned char lexDFCCmd(const char *YYCURSOR){

    {
        unsigned char yych;
        yych = *YYCURSOR;
        if (yych == ' ') goto yy191;
        ++YYCURSOR;
        yy190:
        { return 0;}
        yy191:
        yych = *(++YYCURSOR);
        if (yych != 'G') goto yy190;
        yych = *++YYCURSOR;
        if (yych == 'E') goto yy194;
        yy194:
        yych = *++YYCURSOR;
        if (yych != 'T') goto yy190;
        yych = *++YYCURSOR;
        if (yych != '_') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'C') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'O') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'M') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'M') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'A') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'N') goto yy190;
        yych = *++YYCURSOR;
        if (yych != 'D') goto yy190;
        yych = *++YYCURSOR;
        if (yych >= 0x01) goto yy190;
        ++YYCURSOR;
        {return 1;}
    }

}

static const unsigned char B64Table[128] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                                             0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 0, 0, 0, 0, 1 };

inline unsigned char B64LookUp(const char* msg) {
    msg += 5;
    const unsigned short int* message = (const unsigned short int*) msg;

    int i = 0;
    for (; B64Table[(message[i] & 0x7F00) >> 8] && B64Table[message[i] & 0x7F]; ++i) {}

    i *= 2;
    for (; B64Table[msg[i]]; ++i) {}
    int equals = 0;
    while (msg[i] == '=') {
        ++equals;
        ++i;
    }

    if ((i) % 4 || equals > 2 || msg[i]) {
        return 0;
    }

    return 1;
}

static const unsigned char DFCTable[128] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                             0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                             1, 1, 0, 0, 0, 0, 1 };

inline unsigned char DFCLookUpCMD(const char* msg) {
    int i;
    for (i = 12; DFCTable[msg[i]]; ++i) {}

    return lexDFCCmd(msg + i);
}

inline unsigned char DFCLookUpData(const char* msg) {
    int i;
    for (i = 9; DFCTable[msg[i]]; ++i) {}

    return lexDFCData(msg + i);
}

inline unsigned char DFCLookUpFile(const char* msg) {
    int i;
    for (i = 9; DFCTable[msg[i]]; ++i) {}

    return lexDFCFile(msg + i);
}

static unsigned char status = 1;
enum test_status validate_message(struct Message* msg) {

    //return *(enum test_status*)((unsigned int*)msg - 1);

    if (!msg->direction) { //fwd A_TO_B
        switch (status) {
            case 1:
                if (!lexConnect(msg->text_message)) {
                    status = 1;
                    return MESSAGE_INVALID;
                }
                status = 2;
                return MESSAGE_VALID;

            case 3:
                status = lexCmd(msg->text_message);
                if (!status) {
                    status = 1;
                    return MESSAGE_INVALID;
                }
                return MESSAGE_VALID;
            default:
                status = 1;
                return MESSAGE_INVALID;
        }
    }
    else { //back B_TO_A
        switch (status) {
            case 2:
                if (!lexConnectOk(msg->text_message)) {
                    status = 1;
                    return MESSAGE_INVALID;
                }
                status = 3;
                return MESSAGE_VALID;

            case 4:
                if (!lexVer(msg->text_message)) {
                    status = 1;
                    return MESSAGE_INVALID;
                }
                status = 3;
                return MESSAGE_VALID;

            case 5: {
                const unsigned char res = lexDFCStart(msg->text_message);
                if (res == 13) {
                    if (DFCLookUpCMD(msg->text_message)) {
                        status = 3;
                        return MESSAGE_VALID;
                    }
                }
                else if (res == 11) {
                    if (DFCLookUpData(msg->text_message)) {
                        status = 3;
                        return MESSAGE_VALID;
                    }
                }
                else if (res == 12) {
                    if (DFCLookUpFile(msg->text_message)) {
                        status = 3;
                        return MESSAGE_VALID;
                    }
                }

                status = 1;
                return MESSAGE_INVALID;
            }

            case 6:
                if (!lexB64New(msg->text_message) || !B64LookUp(msg->text_message)) {
                    status = 1;
                    return MESSAGE_INVALID;
                }
                status = 3;
                return MESSAGE_VALID;

            case 7:
                status = 1;
                if (!lexDisconnectOk(msg->text_message)) {
                    return MESSAGE_INVALID;
                }
                return MESSAGE_VALID;

            default:
                status = 1;
                return MESSAGE_INVALID;
        }
    }
}